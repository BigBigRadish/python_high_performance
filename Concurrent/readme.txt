实现并发性
在有些程序中，大部分时间都花在等待速度比cpu慢的资源(磁盘和网络资源)上
异步编程是一种编程范式，可处理速度缓慢且不可预测的资源(用户），它被广泛用于打造响应迅速的服务和用户界面。
本节使用协程和响应式编程进行异步编程
本章主要内容：
存储器层次结构
回调函数
future
事件循环
使用asyncio编写协程
将同步代码转换为异步代码
使用RxRy进行响应式编程
使用被观察者
使用RxRy打造内存监视器
一.存储器层次结构
异步编程可以高效的处理多种资源，需要处理外部请求，外部请求到达顺序不可测。
(1.)等待IO
寄存器，缓存，内存，外存
(2.)并发
并发是一种实现系统同时处理多个请求的方式，其原理是在等待资源期间着手处理其他资源。将任务划分成可不按顺序执行的子任务，这样就能同时处理多个子任务。
如network_request.py模拟一个简单的网络通信例子
二.回调函数
这个例子主要是由于程序阻塞造成的，最简单的方法是使用回调函数，其策略与我们叫出租车相似。
假设你在饭店喝酒，而外面下着雨，你不想去坐公交，于是决定叫辆出租车，并让司机到达后给你打电话。这样就避免雨中等待。
如callback.py所示
三.future
future是一种更便利的模式，可用来跟踪异步调用的结果。前面的代码，没有返回结果，只是跟踪一个回调函数，并在结果就绪后传递这个回调函数。目前为止，没有跟踪资源的
有效途径
future是一种抽象，可帮助我们跟踪请求的资源并等到他可用。在Pyhton中，concurrent.future.Future类提供了一种future实现。要创建这个类的实例，可调用其构造函数且不提供
任何参数。详见async_future.py
四.事件循环
前面回调函数使用的是操作系统线程来进行并行，但在很多异步框架中，并发任务之间的协调工作是由事件循环来管理。
事件循环的理念是，不断地监视各种资源的状态，并在事件发生时执行相应的回调函数.
为何不坚持使用线程，因为每个执行单元都不会与其他单元同时运行，这简化了共享变量，数据结构和资源的处理工作。
通过使用循环不断轮训来等待事件发生，这被称为忙等待。事件循环的局限性在于绝不能使用阻塞调用，因为执行流程是不断运行的循环管理的。
如event_circle.py所示。
五.使用asyncio编写协程
(1.)asyncio框架
获取asyncio循环，可调用函数asyncio.get_event_loop(),调度回调函数，可使用loop.call_later，它接受以秒为单位的延迟和一个回调函数。还可使用
loop.stop停止循环，退出程序。要开始处理已调度的调用，必须启动循环，为此可使用loop.run_forever,demo如asyncio_demo.py所示。
(2.)协程
协程是另一种将程序划分成小块的方式，编写同步代码，异步执行。可停止，可恢复的函数。
生成器例子gen_demo.py


